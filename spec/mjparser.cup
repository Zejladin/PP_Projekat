package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;
terminal PROG, OP_LBRACE, OP_RBRACE, CONST, OP_SEMI, OP_ASSIGN, OP_COMMA, OP_LSQUARE, OP_RSQUARE, ABSTRACT, CLASS;
terminal EXTENDS, OP_LPAREN, OP_RPAREN, VOID, IF, FOR, BREAK, CONTINUE, RETURN, READ, PRINT, ELSE;
terminal INC, DEC, OP_OR, OP_AND, OP_MINUS, OP_DOT, OP_NOT_EQUAL, OP_GREATER, OP_GREATER_EQUAL, OP_LESS, OP_LESS_EQUAL, OP_EQUAL;
terminal NEW, OP_MUL, OP_DIV, OP_MOD, OP_PLUS; 

nonterminal Program, ProgramName, ProgramDeclList, MethodDeclList, MethodDecl;
nonterminal ConstDeclList, VarDeclList, AbstractClassDecl, ClassDecl, Type, ConstDeclNode, ConstDeclTail;
nonterminal VarDeclNode, VarDeclTail, ExtendsOption, AbstractClassMethodsOption, AbstractClassMethods, AbstractMethodDecl;
nonterminal MethodTypeOption, FormParsOption, StatementList, FormPars, Statement, FormParsNode, FormParsTail;
nonterminal DesignatorStatement, Condition, ElseOption, DesignatorStatementOption, ConditionOption, Expr, Designator;
nonterminal Assignop, ActPars, CondTerm, ConditionTail, CondFact, CondTermTail, Relop, Term, ExprTail;
nonterminal Addop, DesignatorTail, ActParsTail, Factor, TermTail, Mulop, ActParsOption;

precedence left ELSE;

Program ::= (Program) PROG IDENT:programName ProgramDeclList OP_LBRACE MethodDeclList OP_RBRACE;

ProgramDeclList ::= (ProgramDeclConst) ProgramDeclList ConstDeclList
				|
				(ProgramDeclVar) ProgramDeclList VarDeclList
				|
				(ProgramDeclAbstractClass) ProgramDeclList AbstractClassDecl
				|
				(ProgramDeclClass) ProgramDeclList ClassDecl
				|
				(NoProgramDecl) /*nothing*/
				;

MethodDeclList ::= (MethodDeclList) MethodDeclList MethodDecl
				|
				(NoMethodDeclList) /*nothing*/
				;
				
ConstDeclList ::= (ConstDeclList) CONST Type ConstDeclNode ConstDeclTail OP_SEMI;

ConstDeclNode ::= (ConstDeclNum) IDENT:constName OP_ASSIGN NUM_CONST:constVal
				|
				(ConstDeclChar) IDENT:constName OP_ASSIGN CHAR_CONST:constVal
				|
				(ConstDeclBool) IDENT:constName OP_ASSIGN BOOL_CONST:constVal
				;
				
ConstDeclTail ::= (ConstDeclTail) ConstDeclTail OP_COMMA ConstDeclNode
				|
				(NoConstDeclTail) /* nothing */
				;
				
VarDeclList ::= (VarDeclList) Type VarDeclNode VarDeclTail OP_SEMI;

VarDeclNode ::= (VarDeclNode) IDENT:varName
				|
				(VarDeclNodeArray) IDENT:varName OP_LSQUARE OP_RSQUARE
				;
				
VarDeclTail ::= (VarDeclTail) VarDeclTail OP_COMMA VarDeclNode
			|
			(NoVarDeclTail) /* nothing */
			;
			
Type ::= (Type) IDENT:typeName;

AbstractClassDecl ::= (AbstractClassDecl) ABSTRACT CLASS IDENT ExtendsOption OP_LBRACE VarDeclList AbstractClassMethodsOption OP_RBRACE;

ExtendsOption ::= (ExtendsOption) EXTENDS Type
			|
			(NoExtendsOption) /* nothing */
			;
			
AbstractClassMethodsOption ::= (AbstractClassMethodsOption) OP_LBRACE AbstractClassMethods OP_RBRACE
							|
							(NoAbstractClassMethodsOptions) /* nothing */
							;
							
AbstractClassMethods ::= (AbstractClassMethodsMethod) AbstractClassMethods MethodDecl
						|
						(AbstractClassMethodsAbstractMethod) AbstractClassMethods AbstractMethodDecl
						|
						(NoAbstractClassMethods) /* nothing */
						;
						
MethodDecl ::= (MethodDecl) MethodTypeOption IDENT OP_LPAREN FormParsOption OP_RPAREN VarDeclList OP_LBRACE StatementList OP_RBRACE;

MethodTypeOption ::= (MethodType) Type
				|
				(VoidMethod) VOID
				;
				
FormParsOption ::= (FormParsOption) FormPars
				|
				(NoFormPars) /* nothing */
				;
				
StatementList ::= (StatementList) StatementList Statement
				|
				(NoStatementList) /* nothing */
				;

AbstractMethodDecl ::= (AbstractMethodDecl) ABSTRACT MethodTypeOption IDENT OP_LPAREN FormParsOption OP_RPAREN OP_SEMI;

FormPars ::= (FormPars) FormParsNode FormParsTail;

FormParsNode ::= (FormParsNode) Type IDENT:paramName
			|
			(FormParsNodeArray) Type IDENT:parName OP_LSQUARE OP_RSQUARE
			;
			
FormParsTail ::= (FormParsTail) FormParsTail OP_COMMA FormParsNode
			|
			(NoFormParsTail) /* nothing */
			;
			
ClassDecl ::= (ClassDeclNoMethods) CLASS IDENT:className ExtendsOption OP_LBRACE VarDeclList OP_RBRACE
			|
			(ClassDeclMethods) CLASS IDENT:className ExtendsOption 	OP_LBRACE VarDeclList OP_LBRACE MethodDeclList OP_RBRACE OP_RBRACE
			;
			
Statement ::= (DesignatorStatement) DesignatorStatement OP_SEMI
			|
			(IfStatement) IF OP_LPAREN Condition OP_RPAREN Statement
			|
			(IfElseStatement) IF OP_LPAREN Condition OP_RPAREN Statement ELSE Statement
			|
			(ForStatement) FOR OP_LPAREN DesignatorStatementOption OP_SEMI ConditionOption OP_SEMI DesignatorStatementOption OP_RPAREN Statement
			|	
			(BreakStatement) BREAK OP_SEMI
			|
			(ContinueStatement) CONTINUE OP_SEMI
			|
			(ReturnStatement) RETURN OP_SEMI
			|	
			(ReturnExprStatement) RETURN Expr OP_SEMI
			|
			(ReadStatement) READ OP_LPAREN Designator OP_RPAREN OP_SEMI
			|
			(PrintStatement) PRINT OP_LPAREN Expr OP_RPAREN OP_SEMI
			|
			(PrintNumStatement) PRINT OP_LPAREN Expr OP_COMMA NUM_CONST OP_RPAREN OP_SEMI
			|
			(StatementStatement) OP_LBRACE StatementList  OP_RBRACE
			;

DesignatorStatement ::= (DesignatorStatementAssignop) Designator Assignop Expr
					|
					(DesignatorStatementActPars) Designator OP_LPAREN ActPars OP_RPAREN
					|
					(DesignatorStatementNoActPars) Designator OP_LPAREN OP_RPAREN
					|
					(DesignatorStatementInc) Designator INC
					|
					(DesignatorStatementDec) Designator DEC
					;	
					
Condition ::= (Condition) CondTerm ConditionTail;	

ConditionTail ::= (ConditionTail) ConditionTail OP_OR CondTerm
				|
				(NoConditionTail) /* nothing */
				;
				
CondTerm ::= (CondTerm) CondFact CondTermTail;	

CondTermTail ::= (CondTermTail) CondTermTail OP_AND CondFact
				|
				(NoCondTermTail) /* nothing */
				;
				
CondFact ::= (CondFact) Expr
		|
		(CondFactRelop) Expr Relop Expr
		;
		
DesignatorStatementOption ::= (DesignatorStatementOption) DesignatorStatement
						|
						(NoDesignatorStatementOption) /* nothing */
						;
						
ConditionOption ::= (ConditionOption) Condition
				|
				(NoConditionOption) /* nothing */
				;
				
Expr ::= (Expr) Term ExprTail
		|
		(ExprMinus) OP_MINUS Term ExprTail
		;
		
ExprTail ::= (ExprTail) ExprTail Addop Term
			|
			(NoExprTail) /* nothing */
			;
			
Designator ::= (Designator) IDENT:designatorName DesignatorTail;

DesignatorTail ::= (DesignatorTailIdent) DesignatorTail OP_DOT IDENT
					|
					(DesignatorTailArray) DesignatorTail OP_LSQUARE Expr OP_RSQUARE
					|
					(NoDesignatorTail) /* nothing */
					;
					
Assignop ::= (Assignop) OP_ASSIGN;

ActPars ::= (ActPars) Expr ActParsTail;

ActParsTail ::= (ActParsTail) ActParsTail OP_COMMA Expr
			|
			(NoActParsTail) /* nothing */
			;
			
Relop ::= (Equal) OP_EQUAL
		|
		(NotEqual) OP_NOT_EQUAL
		|
		(Greater) OP_GREATER
		|
		(GreaterEqual) OP_GREATER_EQUAL
		|
		(Less) OP_LESS
		|
		(LessEqual) OP_LESS_EQUAL
		; 
		
Term ::= (Term) Factor TermTail;

TermTail ::= (TermTail) TermTail Mulop Factor
			|
			(NoTermTail) /* nothing */
			;

ActParsOption ::= (ActParsOption) ActPars
				|
				(NoActParsOption) /* nothing */
				;
				
Factor ::= (DesignatorActParsFactor) Designator OP_LPAREN ActParsOption	OP_RPAREN
			|
			(NumConstFactor) NUM_CONST
			|
			(CharConstFactor) CHAR_CONST
			|
			(BoolConstFactor) BOOL_CONST
			|
			(NewFactor) NEW Type
			|
			(NewExprFactor) NEW Type OP_LSQUARE Expr OP_RSQUARE
			|
			(ExprFactor) OP_LPAREN Expr OP_RPAREN
			;			

Mulop ::= (Mul) OP_MUL
		|
		(Div) OP_DIV
		|
		(Mod) OP_MOD
		;
		
Addop ::= (Plus) OP_PLUS
		|
		(Minus) OP_MINUS
		;	